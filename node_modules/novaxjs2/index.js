const http = require("http");
const fs = require("fs");
const path = require("path");
const url = require("url");
const querystring = require("querystring");
const FileHandler = require("./filehandler");
class Nova {
  constructor() {
    this.routes = [];
    this.styles = "";
    this.staticPath = '';
    this.corsOptions = null;
    this._js = "";
    this.customErrors = {};
    this.middlewares = [];
    this.errorMiddlewares = [];
    this.maxFileSize = 50 * 1024 * 1024;
    this.fileHandler = new FileHandler(this.maxFileSize);
    this.fileConfig = {
      maxSize: this.maxFileSize,
      allowedTypes: [],
      keepOriginalName: false,
      maxFiles: 5
    };
    this.server = http.createServer((req, res) => {
      if (this.corsOptions) {
        this.setCorsHeaders(req, res, this.corsOptions);
      }
      res.status = (statusCode) => {
        res.statusCode = statusCode;
        return res;
      };

      res.redirect = (location, statusCode = 302) => {
        res.writeHead(statusCode, { Location: location });
        res.end();
      };

      res.set = (headers) => {
        for (const key in headers) {
          res.setHeader(key, headers[key]);
        }
        return res;
      };

      req.protocol = req.headers['x-forwarded-proto'] || 'http';
      req.fullUrl = `${req.protocol}://${req.headers.host}${req.url}`;

      
      if (req.method === "OPTIONS") {
        if (this.corsOptions) {
          this.setCorsHeaders(req, res, this.corsOptions);
        }
        res.writeHead(204);
        res.end();
        return;
      }
      const parsedUrl = url.parse(req.url, true);
      req.query = parsedUrl.query;
      req.ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress || req.connection.socket.remoteAddress;

      // Handle multipart/form-data using our custom file handler
       if (req.headers["content-type"] && req.headers["content-type"].startsWith("multipart/form-data")) {
        this.fileHandler.parseMultipartFormData(req)
        .then(({ fields, files }) => {
          req.body = fields;
          req.files = files;
          this.handleRequest(req, res);
        }).catch(err => {
            console.log(err)
            res.end(JSON.stringify({ error: 'File upload failed' }));
        });
        return;
      }

      // Handle other content types (JSON, urlencoded, etc.)
      let body = "";
      req.on("data", (chunk) => {
        body += chunk;
      });
      req.on("end", () => {
        if (req.headers["content-type"] === "application/json") {
          try {
            req.body = JSON.parse(body);
          } catch (err) {
            req.body = {};
          }
        } else if (req.headers["content-type"] === "application/x-www-form-urlencoded") {
          req.body = querystring.parse(body);
        } else {
          req.body = {};
        }
        this.handleRequest(req, res);
      });
    });
  }

  handleRequest(req, res) {
    let i = 0;
    const next = (err) => {
      if (res.headersSent) {
        return;
      }
      if (err) {
        return this.handleError(err, req, res);
      }
      if (i < this.middlewares.length) {
        try {
          this.middlewares[i++](req, res, next);
        } catch (err) {
          next(err);
        }
      } else {
        let matchedRoute = null;
        const pathname = url.parse(req.url).pathname;
        for (const route of this.routes) {
          const match = pathname.match(route.path);
          if (req.method === route.method && match) {
            matchedRoute = route;
            req.params = match.groups;
            break;
          }
        }
        if (matchedRoute) {
          res.json = (data) => {
            if (!res.headersSent) {
              res.writeHead(200, { "Content-Type": "application/json" });
              res.end(JSON.stringify(data));
            }
          };
          res.send = (content, contentType) => {
            if (!res.headersSent) {
              res.writeHead(200, { "Content-Type": contentType || "text/html" });
              res.end(content);
            }
          };
          let content;
          try {
            content = matchedRoute.handler(req, res);
            if (content instanceof Promise) {
              content.then(result => {
                if (typeof result === 'string') {
                  result = `${this.styles}${result}${this._js}`;
                  if (!res.headersSent) {
                    res.writeHead(200, { "Content-Type": "text/html" });
                    res.end(result);
                  }
                } else {
                  res.json(result);
                }
              }).catch(next);
            } else {
              if (typeof content === 'string') {
                content = `${this.styles}${content}${this._js}`;
                if (!res.headersSent) {
                  res.writeHead(200, { "Content-Type": "text/html" });
                  res.end(content);
                }
              } else {
                res.json(content);
              }
            }
          } catch (err) {
            return next(err);
          }
        } else {
          if (this.staticPath && req.url.startsWith(this.staticPath)) {
          this.serveStaticFile(req, res, () => {
            // If static file serving fails, show 404
            this.show404(req, res);
          });
        } else {
          // Not a static file, show 404
          this.show404(req, res);
        }
        }
      }
    };
    next();
  }

  handleError(err, req, res) {
    let i = 0;
    const next = (error) => {
      if (i < this.errorMiddlewares.length) {
        this.errorMiddlewares[i++](error || err, req, res, next);
      } else {
        res.writeHead(500, { "Content-Type": "text/html" });
        res.end(`<p>Error 500: Internal Server Error</p><p>${err.message}</p>`);
      }
    };
    next(err);
  }

  show404(req, res) {
  if (this.customErrors[404]) {
    const errorContent = this.customErrors[404]();
    if (!res.headersSent) {
      res.writeHead(404, { "Content-Type": "text/html" });
      res.end(errorContent || `<p>Error 404: Not Found</p><p>Method: ${req.method}</p><p>Requested Route: ${req.url}</p>`);
    }
  } else {
    if (!res.headersSent) {
      res.writeHead(404, { "Content-Type": "text/html" });
      res.end(`<p>Error 404: Not Found</p><p>Method: ${req.method}</p><p>Requested Route: ${req.url}</p>`);
    }
  }
}

  set style(value) {
    this.styles = `<style>${value}</style>`;
  }

  set js(value) {
    this._js = `<script>${value}</script>`;
  }

  on(statusCode, handler) {
    this.customErrors[statusCode] = handler;
  }

  at(port, host, callback) {
    if (typeof host === 'function') {
      callback = host;
      host = 'localhost';
    }
  this.server.listen(port, host, callback);
}

get(path, ...handlers) {
  const handler = handlers.pop(); // Last function is the route handler
  const middlewares = handlers; // All others are middlewares
  const regexPath = path.replace(/:([\w]+)/g, "(?<$1>[^/]+)");
  
  this.routes.push({ 
    method: "GET", 
    path: new RegExp(`^${regexPath}$`), 
    handler: async (req, res) => {
      try {
        // Execute middlewares in sequence
        for (const middleware of middlewares) {
          await new Promise((resolve, reject) => {
            middleware(req, res, (err) => {
              if (err) return reject(err);
              resolve();
            });
          });
        }
        // Execute the main handler
        return handler(req, res);
      } catch (err) {
        throw err; // Let your existing error handling deal with it
      }
    }
  });
}

post(path, ...handlers) {
  const handler = handlers.pop();
  const middlewares = handlers;
  const regexPath = path.replace(/:([\w]+)/g, "(?<$1>[^/]+)");
  
  this.routes.push({ 
    method: "POST", 
    path: new RegExp(`^${regexPath}$`), 
    handler: async (req, res) => {
      try {
        for (const middleware of middlewares) {
          await new Promise((resolve, reject) => {
            middleware(req, res, (err) => {
              if (err) return reject(err);
              resolve();
            });
          });
        }
        return handler(req, res);
      } catch (err) {
        throw err;
      }
    }
  });
}

put(path, ...handlers) {
  const handler = handlers.pop();
  const middlewares = handlers;
  const regexPath = path.replace(/:([\w]+)/g, "(?<$1>[^/]+)");
  
  this.routes.push({ 
    method: "PUT", 
    path: new RegExp(`^${regexPath}$`), 
    handler: async (req, res) => {
      try {
        for (const middleware of middlewares) {
          await new Promise((resolve, reject) => {
            middleware(req, res, (err) => {
              if (err) return reject(err);
              resolve();
            });
          });
        }
        return handler(req, res);
      } catch (err) {
        throw err;
      }
    }
  });
}

delete(path, ...handlers) {
  const handler = handlers.pop();
  const middlewares = handlers;
  const regexPath = path.replace(/:([\w]+)/g, "(?<$1>[^/]+)");
  
  this.routes.push({ 
    method: "DELETE", 
    path: new RegExp(`^${regexPath}$`), 
    handler: async (req, res) => {
      try {
        for (const middleware of middlewares) {
          await new Promise((resolve, reject) => {
            middleware(req, res, (err) => {
              if (err) return reject(err);
              resolve();
            });
          });
        }
        return handler(req, res);
      } catch (err) {
        throw err;
      }
    }
  });
}

  useMiddleware(middleware) {
    this.middlewares.push(middleware);
  }

  useErrorMiddleware(middleware) {
    this.errorMiddlewares.push(middleware);
  }

  serveStatic(customDir = 'public') {
  this.staticPath = customDir;
  this.useMiddleware((req, res, next) => {
    // Strip the static path prefix if it exists in the URL
    const staticPrefix = `/${customDir}`;
    if (req.url.startsWith(staticPrefix)) {
      req.url = req.url.slice(staticPrefix.length) || '/';
    }
    this.serveStaticFile(req, res, next);
  });
}

  serveStaticFile(req, res, next) {
    const parsedUrl = url.parse(req.url, true);
    const filePath = path.join(process.cwd(), this.staticPath, parsedUrl.pathname);

    fs.stat(filePath, (err, stats) => {
      if (err || !stats.isFile()) {
        return next();
      }

      fs.readFile(filePath, (err, data) => {
        if (err) {
          return next();
        }

        const extname = path.extname(filePath);
        const mimeTypes = JSON.parse(fs.readFileSync(path.join(__dirname, 'mimetype.json'), 'utf8'));

        const contentType = mimeTypes[extname] || 'text/html';
        res.writeHead(200, { "Content-Type": contentType });
        res.end(data);
      });
    });
  }

  error(handler) {
    this.useErrorMiddleware((err, req, res, next) => {
      const statusCode = err.statusCode || 500;
      res.writeHead(statusCode, { "Content-Type": "text/html" });
      res.end(handler(err, req, res));
    });
  }

  sendFile(filePath, contentTypeOrRes, res) {
    // Determine parameter pattern (2 or 3 arguments)
    let contentType, response;
    
    if (arguments.length === 2) {
        // Pattern: sendFile(filePath, res)
        response = contentTypeOrRes;
        contentType = 'text/html'; // default content type
    } else {
        // Pattern: sendFile(filePath, contentType, res)
        contentType = contentTypeOrRes;
        response = res;
    }

    // Validate response object
    if (!response || typeof response.writeHead !== 'function') {
        throw new Error('Valid response object is required');
    }

    // Handle missing file path
    if (!filePath) {
        response.writeHead(404, { 'Content-Type': 'text/html' });
        return response.end('File not found');
    }

    const resolvedPath = path.resolve(filePath);
    
    // Check if file exists
    if (!fs.existsSync(resolvedPath)) {
        response.writeHead(404, { 'Content-Type': 'text/html' });
        return response.end('File not found');
    }

    // Set default content type if not provided
    const type = contentType || 'text/html';
    
    try {
        const fileContent = fs.readFileSync(resolvedPath);
        response.writeHead(200, { 'Content-Type': type });
        return response.end(fileContent);
    } catch (err) {
        response.writeHead(500, { 'Content-Type': 'text/html' });
        return response.end('Error reading file');
    }
}

  setCorsHeaders(req, res, options) {
    // Allow all origins if '*' is specified
    if (options.origins.includes('*')) {
      res.setHeader("Access-Control-Allow-Origin", '*');
    } else {
      const origin = req.headers.origin;
      if (options.origins.includes(origin)) {
        res.setHeader("Access-Control-Allow-Origin", origin);
      }
    }
    
    res.setHeader("Access-Control-Allow-Methods", options.methods || "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", options.headers || "Content-Type, Authorization");
    
    // Important for credentials if you use them
    if (options.credentials) {
      res.setHeader("Access-Control-Allow-Credentials", "true");
    }
  }

  cors(options) {
    this.corsOptions = options;
  }

  /**
 * Set multiple file upload configurations at once
 * @param {Object} config - Configuration object
 * @param {number} config.maxSize - Max file size in MB
 * @param {string[]} config.allowedTypes - Allowed MIME types
 * @param {number} config.maxFiles - Maximum number of files
 */

  setFileConfig(config) {
    // Validate and update each configuration
    if (config.maxSize !== undefined) {
      this.setFileSizeLimit(config.maxSize);
    }
    if (config.allowedTypes !== undefined) {
      this.setAllowedFileTypes(config.allowedTypes);
    }
    if (config.keepOriginalName !== undefined) {
      this.setKeepOriginalName(config.keepOriginalName);
    }
    if (config.maxFiles !== undefined) {
      this.setMaxFiles(config.maxFiles);
    }
  }

  /**
 * Set allowed file types
 * @param {string[]} types - Array of MIME types (e.g., ['image/jpeg', 'application/pdf'])
 */

  setAllowedFileTypes(types) {
    if (!Array.isArray(types)) {
      throw new Error('Allowed types must be an array');
    }
    this.fileConfig.allowedTypes = types;
    this.fileHandler.allowedTypes = types;
  }
  
  /**
   * Set maximum number of files allowed in a single upload
   * @param {number} max - Maximum number of files
  */
  setMaxFiles(max) {
    if (typeof max !== 'number' || max <= 0) {
     throw new Error('Max files must be a positive number');
    }
    this.fileConfig.maxFiles = max;
    this.fileHandler.maxFiles = max;
  }

  /**
 * Set whether to keep original filenames
 * @param {boolean} keep - Whether to keep original filenames
 */
  setKeepOriginalName(keep) {
    this.fileConfig.keepOriginalName = Boolean(keep);
    this.fileHandler.keepOriginalName = Boolean(keep);
  }

  /**
 * Set maximum file size limit
 * @param {number} sizeInMB - Maximum size in megabytes
 */

  setFileSizeLimit(sizeInMB) {
    if (typeof sizeInMB !== 'number' || sizeInMB <= 0) {
      throw new Error('File size limit must be a positive number');
    }
    this.maxFileSize = sizeInMB * 1024 * 1024;
    this.fileHandler.maxFileSize = this.maxFileSize;
  }

  setViewEngine(engine, options = {}) {
    this.viewEngine = engine;
    this.viewsPath = options.viewsPath || path.join(process.cwd(), 'views');
    
    try {
      fs.mkdirSync(this.viewsPath, { recursive: true });
    } catch (err) {
      console.error('Could not create views directory:', err);
    }
  }
  
  usePlugin(plugin, options = {}) {
  if (typeof plugin !== 'function') {
    throw new Error('Plugin must be a function');
  }

  // Create a context object with properly bound methods
  const context = {
    app: this,
    options,
    addMethod: (name, fn) => {
      if (this[name]) {
        console.warn(`Warning: Overwriting existing method '${name}'`);
      }
      this[name] = fn.bind(this);
    },
    addRoute: (method, path, handler) => {
      this[method.toLowerCase()](path, handler);
    },
    addMiddleware: (fn) => {
      this.useMiddleware(fn);
    },
    addErrorMiddleware: (fn) => {
      this.useErrorMiddleware(fn);
    },
    setConfig: (key, value) => {
      if (!this._config) this._config = {};
      this._config[key] = value;
    },
    getConfig: (key) => {
      return this._config?.[key];
    }
  };

  // Call the plugin with the context and options
  plugin(context, options);

  // Return this for chaining
  return this;
}


  render(file, data = {}) {
  return new Promise((resolve, reject) => {
    if (!this.viewEngine) {
      return reject(new Error('No view engine configured'));
    }

    let filePath = null;
    if (this.viewEngine === 'novax') {
      filePath = path.join(this.viewsPath, `${file}.html`);
    } else {
      const errorMessage = `Unsupported view engine: ${this.viewEngine}. Supported engines: 'novax'`;
      console.error(errorMessage);
      return reject(new Error(errorMessage));
    }

    fs.readFile(filePath, 'utf8', (err, content) => {
      if (err) return reject(err);

      // Improved evaluate function with proper this handling
      const evaluate = (expr, context) => {
        try {
          // Special case for {{this}}
          if (expr.trim() === 'this') {
            return context;
          }

          // Create a safe evaluation context
          const evalContext = {
            ...context,
            this: context, // Proper this reference
            JSON: JSON     // Include JSON helper
          };

          // Handle this.property access
          if (expr.startsWith('this.')) {
            const prop = expr.substring(5);
            return evalContext[prop];
          }

          // Try direct property access first
          if (expr in evalContext) {
            return evalContext[expr];
          }

          // Fallback to evaluating the expression
          try {
            return new Function('data', `with(data) { return ${expr} }`)(evalContext);
          } catch {
            return undefined;
          }
        } catch {
          return undefined;
        }
      };

      // Helper: process if/elif/else blocks
      const processConditionals = (template, context) => {
        return template
          // Handle if/elif/else blocks
          .replace(
            /\{\{#if (.+?)\}\}([\s\S]+?)((?:\{\{#elif .+?\}\}[\s\S]+?)*)\{\{#else\}\}([\s\S]+?)\{\{\/if\}\}/g,
            (match, ifCond, ifBlock, elifBlocks, elseBlock) => {
              if (evaluate(ifCond, context)) return processConditionals(ifBlock, context);

              const elifMatches = [
                ...elifBlocks.matchAll(
                  /\{\{#elif (.+?)\}\}([\s\S]+?)(?=(\{\{#elif|\{\{#else|\{\{\/if\}\}))/g
                )
              ];
              for (const [, cond, block] of elifMatches) {
                if (evaluate(cond, context)) return processConditionals(block, context);
              }

              return processConditionals(elseBlock, context);
            }
          )
          // Handle simple if blocks
          .replace(/\{\{#if (.+?)\}\}([\s\S]+?)\{\{\/if\}\}/g, (_, condition, block) => {
            return evaluate(condition, context) ? processConditionals(block, context) : '';
          });
      };

      // Process each blocks with proper context handling
      content = content.replace(
        /\{\{#each (.+?)\}\}([\s\S]+?)\{\{\/each\}\}/g,
        (_, arrayExpr, innerTemplate) => {
          const array = evaluate(arrayExpr, data);
          if (!Array.isArray(array)) return '';

          return array
            .map(item => {
              // Create proper context with this reference
              const context = typeof item === 'object' ? 
                { ...item, this: item } : 
                { this: item };

              // Process the inner template
              let processed = processConditionals(innerTemplate, context);

              // Handle variable interpolation
              processed = processed.replace(/\{\{\s*(.+?)\s*\}\}/g, (_, expr) => {
                const result = evaluate(expr, context);
                if (result === undefined) return '';
                if (typeof result === 'object') return JSON.stringify(result);
                return result;
              });

              return processed;
            })
            .join('');
        }
      );

      // Process top-level conditionals
      content = processConditionals(content, data);

      // Process top-level variable interpolation
      content = content.replace(/\{\{\s*(.+?)\s*\}\}/g, (_, expr) => {
        const result = evaluate(expr, data);
        if (result === undefined) return '';
        if (typeof result === 'object') return JSON.stringify(result);
        return result;
      });

      resolve(content);
    });
  });
}

}

module.exports = Nova;